#
# Replaces the classic BotBuilder-DotNet-master-CI-PR
#

# "name" here defines the build number format. Build number is accessed via $(Build.BuildNumber)
name: $(Build.BuildId)

pool:
  name: Hosted Windows 2019 with VS2019
  demands:
  - msbuild
  - visualstudio

# No "paths exclude" here: not supported by github required status checks.
trigger: # ci trigger
  branches:
    include:
     - main

pr: # pr trigger
  branches:
    include:
     - main

variables:
  ApiCompatVersion: 4.6.3
  BotBuilderDll: Microsoft.Bot.Builder.AI.Luis,Microsoft.Bot.Builder.AI.QnA,Microsoft.Bot.Builder.ApplicationInsights,Microsoft.Bot.Builder.Azure,Microsoft.Bot.Builder.Dialogs,Microsoft.Bot.Builder.Integration.ApplicationInsights.Core,Microsoft.Bot.Builder.Integration.AspNet.Core,Microsoft.Bot.Builder.TemplateManager,Microsoft.Bot.Builder.Testing,Microsoft.Bot.Builder,Microsoft.Bot.Configuration,Microsoft.Bot.Connector,Microsoft.Bot.Schema,Microsoft.Bot.Streaming
  BuildConfiguration: Release-Windows
  BuildPlatform: any cpu
#  DotNetCoverallsToken: define this in Azure
#  GitHubCommentApiKey: define this in Azure
  IsBuildServer: true # This activates package versioning in the projects in Microsoft.Bot.Builder.sln.
  MSBuildArguments: -p:SignAssembly=false -p:delaySign=false
  Parameters.solution: Microsoft.Bot.Builder.sln
  PreviewPackageVersion: 4.9.0-preview-$(Build.BuildNumber) # This is consumed by projects in Microsoft.Bot.Builder.sln.
  ReleasePackageVersion: 4.9.0-preview-$(Build.BuildNumber) # This is consumed by projects in Microsoft.Bot.Builder.sln.
  runCodesignValidationInjection: false # Disables unnecessary CodeSign Validation step

# The following 2 stages run multi-configuration, multi-agent parallel jobs.
# Debug-Windows/Release-Windows => Builds everything in Debug/Release + the ASP.NET Desktop.
# Debug/Release => would build all .NET Standard libs and test them.
# The .NET 4.X asp.net integrations libraries do not build and test on non-windows boxes.
# If we drop support for .NET 4.x then we can drop to just Debug/Release.
steps:
- powershell: 'gci env:* | sort-object name | Format-Table -AutoSize -Wrap'
  displayName: 'Display environment variables'
  enabled: false

# Variables ReleasePackageVersion and PreviewPackageVersion are consumed by projects in Microsoft.Bot.Builder.sln.
# For the signed build, they should be settable at queue time. To set that up, define the variables in Azure on the Variables tab.
- task: colinsalmcorner.colinsalmcorner-buildtasks.tag-build-task.tagBuildOrRelease@0
  displayName: 'Tag build with package version'
  inputs:
    tags: 'Version=$(ReleasePackageVersion)'
  continueOnError: true

- task: NuGetToolInstaller@0
  displayName: 'Install NuGet'

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(Parameters.solution)'

- task: VSBuild@1
  displayName: 'Build'
  inputs:
    solution: '$(Parameters.solution)'
    vsVersion: 16.0
    msbuildArgs: '$(MSBuildArguments)'
    platform: '$(BuildPlatform)'
    configuration: '$(BuildConfiguration)'
    logProjectEvents: false

# Required for Schema merge tests.
- task: Npm@1
  displayName: 'Install botframework-cli'
  inputs:
    command: custom
    verbose: false
    customCommand: 'install -g @microsoft/botframework-cli@next'

- task: DotNetCoreCLI@2
  displayName: 'Test'
  inputs:
    command: test
    projects: |
     Tests/**/*Tests.csproj
    arguments: '-v n --configuration release --no-build --no-restore --filter "TestCategory!=IgnoreInAutomatedBuild&TestCategory!=FunctionalTests" --collect:"Code Coverage" --settings $(Build.SourcesDirectory)\CodeCoverage.runsettings'
  condition: succeeded()

# This task copies the code coverage file created by dotnet test into a well known location. 
# In all checks I've done, dotnet test ALWAYS outputs the coverage file to the temp directory. 
# My attempts to override this and have it go directly to the CodeCoverage directory have all failed, so I'm just doing the copy here.  
# (cmullins)
- powershell: |
    Remove-Item CodeCoverage -Force -Recurse -ErrorAction Ignore
    New-Item CodeCoverage -ItemType Directory -Force
    Get-ChildItem -Path "D:\a\_temp" -Include "*.coverage" -Recurse | Copy-Item -Destination CodeCoverage
    echo '##vso[task.setvariable variable=CoverallsToken]$(DotNetCoverallsToken)'
  displayName: 'Copy code coverage files'
  condition: succeeded()

# To Coveralls.io https://coveralls.io/github/microsoft/botbuilder-dotnet
- task: PowerShell@2
  displayName: 'Upload code coverage files'
  inputs:
    targetType: filePath
    filePath: '$(Build.SourcesDirectory)\build\PublishToCoveralls.ps1'
    arguments: '-pathToCoverageFiles "$(Build.SourcesDirectory)\CodeCoverage" -serviceName "master CI-PR"'
  continueOnError: true
  condition: succeeded()

- powershell: |
    if ("$(Build.Reason)" -eq 'PullRequest') {
      $libraries = ($env:BotBuilderDll).Split(",")
      $updatedLibraries = [System.Collections.ArrayList]@()
      $updatedFiles = $(git diff HEAD HEAD~ --name-only)
      foreach ($updatedFile in $updatedFiles) {
        $updatedLibrary = ''
        foreach ($library in $libraries) {
          if($updatedFile -like ('*/' + $library + '/*')){
            $updatedLibraries.Add($library)
          }
        }
      }
    }
    echo "##vso[task.setVariable variable=BotBuilderUpdatedDll]$updatedLibraries.Join(',')"
    Write-Host ("Found " + $updatedLibraries.Count + " librar" + $(If ($updatedLibraries.Count -eq 1) {"y"} Else {"ies"}) + " to compare.")
  displayName: 'Evaluate updated libraries'
  enabled: false

- powershell: |
    $xml = "<?xml version=""1.0"" encoding=""utf-8""?>`n<packages>`n"
    # $(BotBuilderUpdatedDll).Split(",") | ForEach-Object {
    ($env:BotBuilderDll).Split(",") | ForEach-Object {
      $library = $_.Trim()
      $xml += "  <package id=""" + $library + """ version=""" + $env:ApiCompatVersion + """/>`n"
    }
    $xml += "</packages>"
    New-Item -Path $(System.DefaultWorkingDirectory) -Name "packages.config" -ItemType "file" -Value $xml -Force
  displayName: 'Generate packages.config'

- task: NuGetCommand@2
  displayName: 'NuGet Install'
  inputs:
    command: custom
    arguments: 'install $(System.DefaultWorkingDirectory)\packages.config -OutputDirectory $(System.DefaultWorkingDirectory)\DownloadedNuGet'

- powershell: |
    New-Item -ItemType directory -Path "implementation\" -Force
    $env:BotBuilderDll.Split(",") | ForEach {
        $library = $_.Trim()
        Get-ChildItem -Path "*/$library/bin/Release/netstandard2.0/$library.dll" -Recurse | Copy-Item -Destination 'implementation\' -Force
        Get-ChildItem -Path "*/*/$library/bin/Release/netstandard2.0/$library.dll" -Recurse | Copy-Item -Destination 'implementation\' -Force
    }
    # $libraries = ($(BotBuilderUpdatedDll) -replace ",", ".dll ") + ".dll"
    $libraries = (($env:BotBuilderDll) -replace ",", ".dll ") + ".dll"
    Write-Host "##vso[task.setvariable variable=Contracts]$libraries"
    $path = "DownloadedNuGet\**\lib\netstandard2.0\*"
    If (!(Test-Path "contracts\")) {
      New-Item -Path "contracts\" -ItemType Directory
    }
    Copy-Item -Path $path -Destination "contracts\" -Recurse -Force
  displayName: 'Binaries Comparer setup'

- task: CmdLine@1
  displayName: 'Display Contracts directory'
  inputs:
    filename: dir
    arguments: 'contracts\*.* /s'
  enabled: false

- task: SOUTHWORKS.binaries-comparer.custom-build-release-task.binaries-comparer@0
  displayName: 'Binaries Comparer run'
  inputs:
    contractsRootFolder: 'contracts\'
    contractsFileName: '$(Contracts)'
    implFolder: 'implementation\'
    failOnIssue: true
    resolveFx: false
    generateLog: true
    outputFilename: 'results.txt'
    outputFolder: '$(System.DefaultWorkingDirectory)\binaries-comparer'
    useBaseline: false

- powershell: |
    $FilePath = "$(System.DefaultWorkingDirectory)/binaries-comparer"
    $FileName = "results.txt"
    $FileFullPath = $FilePath + $FileName
    $FileContent = @(Get-Content $FileFullPath)
    $result = ''
    $failed = $FALSE;
    ForEach ($line in $FileContent) {
      if ($line.StartsWith(':x:','CurrentCultureIgnoreCase')) {
        $failed = $TRUE
        $result += ":x: Found an incompatibility in at least one of all modified libraries:`n"
        $result += $line.Replace(":x: ", "") + "`n"
      } elseif ($failed) {
        $result += $line + "`n"
      } else {
        $firstIndex =  $line.IndexOf('**') + 2
        $lastIndex = $line.LastIndexOf('**')
        $libraries = $line.Substring($firstIndex, $lastIndex - $firstIndex).Split(' ')
        $result = ":heavy_check_mark: Found no incompatibilities for all modified libraries:`n"
        ForEach ($library in $libraries) {
          $libraryName = $library.Replace('.dll','') 
          $libraryName += " compared against [version $(ApiCompatVersion)](https://www.nuget.org/packages/$libraryName/$(ApiCompatVersion))"
          $result += '- ' + $libraryName + "`n"
        }
        break;
      }
    }
    Set-Content -Path $FileFullPath -Value $result
  displayName: 'Binaries Comparer format results'
  condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'))

- task: SOUTHWORKS.github-pr-comment.custom-publish-comment-task.github-pr-comment@0
  displayName: 'Binaries Comparer publish results'
  inputs:
    userToken: '$(GitHubCommentApiKey)'
    bodyFilePath: '$(Build.ArtifactStagingDirectory)\'
    getSubFolders: true
  condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'))
  
- powershell: |
    # Check for string in the logs in the current DevOps pipeline run.
    # Note: The task immediately before this one may not get checked because its log may not yet be available.
    # Calls the Azure DevOps REST API.
    # Enable OAuth token access in the pipeline agent job for $(System.Accesstoken) to populate.
    $stringToCheckFor = '201 Created';
    Start-Sleep -Milliseconds 1000 # Give time for the last log to become available
    
    $collectionUri = "$env:SYSTEM_COLLECTIONURI";  # e.g. 'https://fuselabs.visualstudio.com'
    $teamProjectId = "$env:SYSTEM_TEAMPROJECTID";  # e.g. '86659c66-c9df-418a-a371-7de7aed35064' = SDK_v4
    
    # Get the current build ID.
    $buildId = "$env:BUILD_BUILDID";
    Write-Host 'Build ID = ' $buildId;
    
    # Get the log containers for the run.
    $uri = "$collectionUri/$teamProjectId/_apis/build/builds/$buildId/logs";
    
    $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$(System.AccessToken)"));
    $header = @{authorization = "Basic $token"};
    
    $runLogContainers = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
    
    # Get the log from each log container.
    Write-Host 'Checking the logs:';
    $found = $false;
    foreach ($container in $runLogContainers.value) {
        $container.id;
        $uri = $container.url;
        $uri;
        $log = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
        
        # Search for our string.
        if (!$found -and $log.Contains($stringToCheckFor)) {
            $found = $true;
            $log;
            $mess = 'String "' + $stringToCheckFor + '" found in log #' + $container.id;
            Write-Host $mess;
        } else {
            ($log -split '\r?\n')[0] + '...';  # Print first line
        }
    }
    
    # If not found, throw an error.
    if (!$found) {
        Write-Host;
        $mess =  'Publish Compat Results failed. Is there a PR associated with this build? String "' + $stringToCheckFor + '" not found in the logs';
        throw $mess;
    }
  displayName: 'Verify publish'
  continueOnError: true
  condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'))

- script: |
   cd ..
   dir *.* /s
  displayName: 'Dir Workspace'
  continueOnError: true
  condition: succeededOrFailed()
  enabled: false
